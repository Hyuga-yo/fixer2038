# Note: This license has also been called the “Simplified BSD License” and the “FreeBSD License”. See also the 3-clause BSD License.
#
# Copyright 2023 Mizukami Hinata
#
# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
# GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import datetime
import glob
import os
import re
import subprocess
import collections
import shutil
import operator
import argparse

with os.add_dll_directory("C:/Program Files/SciTools/bin/pc-win64"):
    import understand

class TheFile:
    def __init__(self, e):
        self.ent = e
        self.path = e.longname()
        # self.risks = []
        self.functions = []
    
    # def addRiskPoint(self, r):
    #     try:
    #         self.risks.extend(r)
    #     except TypeError as e:
    #         self.risks.append(r)
    
    def addLexer(self, l):
        self.lexer = l
    
    def addFunction(self, f):
        try:
            self.functions.extend(f)
        except TypeError as e:
            self.functions.append(f)
    
    # def sortRiskPoint(self):
    #     self.landr = []
    #     for i, u in enumerate(self.risks):
    #         self.landr.append([u.line, i])
    #     self.landr.sort()
    #     self.newlist = []
    #     for lr in self.landr:
    #         self.newlist.append(self.risks[lr[1]])
    #     self.risks = self.newlist

    def whereIsHere(self, line):
        """Detect Function from Line number"""
        for f in self.functions:
            if (f.line_begin <= line) and (line <= f.line_end):
                return f
        return None

class TheFunction:
    """This class represents a Function in a target file"""
    def __init__(self, e):
        self.obj = e
        self.name = self.obj.name()
        self.rettype = self.obj.type()
        self.params = self.obj.parameters(shownames=False).split(',')
        self.CFGroot = None
        self.CFGend = None

    def declareCheck(self, files):
        """Am I declared in some target file?"""
        self.decref = self.obj.ref("Definein")
        if self.decref is not None:
            self.endref = self.obj.ref("End")
            fent = self.decref.file()
            for f in files:
                if f.ent == fent:
                    self.declaredfile = f
                    self.line_begin = self.decref.line()
                    self.line_end = self.endref.line()
                    f.addFunction(self)
                    break
            else:
                self.declaredfile = None
                self.line_begin = None
                self.line_end = None
        else:
            self.declaredfile = None
            self.line_begin = None
            self.line_end = None

    def cfgMaker(self, path):
        """Read dot files generated by Understand"""
        # Understandのバージョンアップに伴ってdotファイルの書式が変わった場合、このメソッドも修正が必要
        self.nodelist = []
        with open(path, encoding="utf-8") as f:
            self.nowmax = 0
            while True:
                try:
                    self.l = next(f)
                except UnicodeDecodeError as e:
                    return e
                except StopIteration as e:
                    break
                if re.match(r'\s+__N[0-9]+\s\[', self.l) is not None:   # ノード宣言部分
                    self.l = self.l.removeprefix(re.match(r'\s*__N', self.l).group())
                    self.metanum = re.match(r'[0-9]+', self.l).group()  # 出力されたグラフ内のノード番号
                    self.l = self.l.removeprefix(self.metanum)
                    self.l = self.l.removeprefix(re.match(r'.*?label="[^0-9]*', self.l).group())
                    self.nnum = re.match(r'[0-9]+', self.l).group() # 出力されない要素も含めた通しのノード番号
                    self.l = self.l.removeprefix(self.nnum)
                    # l = l.lstrip(re.match(r'[^\\]*(\\n|\\r)+', l).group())
                    self.l = self.l.removeprefix(re.match(r'[^0-9]*', self.l).group())
                    self.parsed = self.l.split(',')
                    self.ntype = self.parsed[0] # ステートメントの分類（passive, if, while-for etc）
                    self.nline_b = self.parsed[1]   # 開始行
                    self.ncolumn_b = self.parsed[2] # 開始列
                    self.nline_e = self.parsed[3]   # 終了行
                    self.ncolumn_e = self.parsed[4] # 終了列
                    self.nnum = int(self.nnum)
                    self.n = PDGNode(self.nnum, int(self.metanum), int(self.nline_b) if self.nline_b != '' else -1, int(self.nline_e) if self.nline_e != '' else -1, int(self.ncolumn_b) if self.ncolumn_b != '' else -1, int(self.ncolumn_e) if self.ncolumn_e != '' else -1, int(self.ntype), self)
                    self.nodelist.append(self.n)
                    if self.nnum == 1:
                        self.CFGroot = self.n
                    if self.nnum > self.nowmax:
                        self.CFGend = self.n
                        self.nowmax = self.nnum
                if re.match(r'\s+__N[0-9]+\s*->\s*__N[0-9]+', self.l) is not None:   # エッジ宣言部分
                    self.l = self.l.removeprefix(re.match(r'\s*__N', self.l).group())
                    self.source = re.match(r'[0-9]+', self.l).group()   # 根本ノード番号（metanumと対応）
                    self.l = self.l.removeprefix(self.source)
                    self.l = self.l.removeprefix(re.match(r'\s*->\s*__N', self.l).group())
                    self.destination = re.match(r'[0-9]+', self.l).group()  # 行先ノード番号（metanumと対応）
                    self.l = self.l.removeprefix(self.destination)
                    for n in self.nodelist:
                        if n.metanum == int(self.source):
                            for nn in self.nodelist:
                                if nn.metanum == int(self.destination):
                                    n.nextnode.append(nn)
                                    nn.prevnode.append(n)
        # 関数の実引数の宣言箇所に相当するダミーノードを作成
        self.sl = self.obj.ref("Definein").line()
        self.newnode = PDGNode(-1, -1, self.sl, max([self.sl, self.CFGroot.nextnode[0].line_begin - 1]), 0, 1024, 35, self)
        self.newnode.nextnode.extend(self.CFGroot.nextnode)
        self.CFGroot.nextnode = [self.newnode]
        self.newnode.prevnode.append(self.CFGroot)
        for self.n in self.newnode.nextnode:
            self.n.prevnode = [self.newnode]

    def dependTreeMaker(self):
        """Calling methods of PDGNodes for make PDG"""
        self.visited = []
        self.tovisit = collections.deque()
        self.tovisit.append(self.CFGroot)
        while len(self.tovisit) != 0:
            self.n = self.tovisit.popleft()
            self.visited.append(self.n)
            for self.nn in self.n.nextnode:
                if self.nn not in self.visited and self.nn not in self.tovisit:
                    self.tovisit.append(self.nn)
            self.n.dependCheck()

class PDGNode:
    def __init__(self, n, mn, lb, le, cb, ce, t, p):
        self.prevnode = []
        self.nextnode = []
        self.references = []
        self.f_dependon = []
        self.f_depended = []
        self.c_dependon = []
        self.c_depended = []
        self.num = n
        self.metanum = mn
        self.line_begin = lb
        self.line_end = le
        self.column_begin = cb
        self.column_end = ce
        self.type = t
        self.parent = p
    #     if lb >= 0 and le >= 0:
    #         self.refSearch()

    # def refSearch(self):
    #     """Search references in code represented by this node"""
    #     global entlist
    #     for self.e in entlist:
    #         for self.r in self.e.refs():
    #             if (not self.r.isforward()) and self.r.file() == self.parent.declaredfile and self.line_begin <= self.r.line() <= self.line_end and ((self.column_begin <= self.r.column()) if (self.line_begin == self.r.line()) else True) and ((self.r.column() <= self.column_end) if (self.line_end == self.r.line()) else True):
    #                 self.references.append([self.e, self.r])

    def dependCheck(self):
        """Make data-dependence(flow-dependence) edges"""
        for self.f in self.references:
            if "Use" in self.f[1].kind().name() or "Type" in self.f[1].kind().name() or "Return" in self.f[1].kind().name():
                self.tovisit = collections.deque(self.prevnode)
                self.visited = []
                while len(self.tovisit) != 0:
                    self.n = self.tovisit.pop()
                    self.visited.append(self.n)
                    for self.r in self.n.references:
                        self.rkind = self.r[1].kind().name()
                        if self.r[0] == self.f[0] and "Use" not in self.rkind and "Type" not in self.rkind and "Return" not in self.rkind and "Modify" not in self.rkind:
                            self.f_dependon.append(self.n)
                            self.n.f_depended.append(self)
                            break
                    else:
                        for self.p in self.n.prevnode:
                            if self.p not in self.visited and self.p not in self.tovisit:
                                self.tovisit.append(self.p)

class FixedTimeVal:
    """This class represents a variavle (or custom function) need to be tracked to fix compare point"""
    def __init__(self, e, func, memname, isyear, line, debug_column):
        self.ent = e
        self.function = func
        self.type = e.type()
        self.ismember = True if (memname is not None) else False
        self.memname = memname
        self.isyear = isyear
        self.startingpoint = line
        self.debug_startcolumn = debug_column

def makeFileList():
    """Get target file path, Make path-list-file for Understand, and Return path list"""
    global cantanalyzed
    pathlist = []
    path = input("Enter File or Directory Path > ")
    if os.path.isfile(path):
        pathlist.append(path)
    elif os.path.isdir(path):
        pathlist.extend(glob.glob(path + os.sep + "**" + os.sep + "*.c", recursive=True))
    else:
        print("This path is illegal!")
    while (path := input("Enter Next Path (or \"None\") > ")) != "None":
        if os.path.isfile(path):
            pathlist.append(path)
        elif os.path.isdir(path):
            pathlist.extend(glob.glob(path + os.sep + "**" + os.sep + "*.c", recursive=True))
        else:
            print("This path is illegal!")
    with open("addfiles.lis", mode='w') as l:
        for p in pathlist:
            if os.path.getsize(p) <= args.filesizelimit:
                with open(p, 'r', encoding='utf-8') as f:
                    fstr = f.read()
                if '\t' in fstr:
                    # タブ幅による不具合を避けるため、タブ文字をスペースに置換
                    with open(p, 'w', encoding='utf-8') as f:
                        f.write(fstr.replace('\t', '    '))
                l.write(p + '\n')
            else:
                cantanalyzed.append(["Too_Big_File", p])
    return pathlist

def pathParse(path):
    """Parse path into filename"""
    if os.sep in path:
        return path.rsplit(os.sep, 1)[1]
    else:
        return path

def analyzeCode():
    """Setting include directory, and Analyze code by Understand"""
    subprocess.run(["und", "create", "-db", "newDB.udb", "-languages", "c++", "-OpenFilesAsReadOnly", "on"])
    subprocess.run(["und", "-db", "newDB.udb", "add", "@addfiles.lis"])
    includedir = input("Enter Include Path (or \"None\") > ")
    while includedir != "None":
        subprocess.run(["und", "settings", "-c++includesadd", includedir, "newDB.udb"])
        includedir = input("Enter Next Include Path (or \"None\") > ")
    subprocess.run(["und", "analyze", "newDB.udb"])
    print("Code analyze by Understand is completed.")
    os.remove("addfiles.lis")

def drawPDG(funcs):
    """Draw CFG and Call PDG builder"""
    errors = []
    tasklen = str(len(funcs))
    print("Drawing CFG... 0/" + tasklen, end="", flush=True)
    os.makedirs("fixer2038_graphfiles", exist_ok=True)
    for i, f in enumerate(funcs, 1):
        if f.declaredfile is not None:
            if f.line_end - f.line_begin > args.functionlinelimit:
                errors.append(['Long_Function', f])
            else:
                f.obj.draw("Control Flow", "fixer2038_graphfiles" + os.sep + str(f.obj.id()) + ".dot", "debug=on;filter=off;collapse=off;passive=on")
                if f.cfgMaker("fixer2038_graphfiles" + os.sep + str(f.obj.id()) + ".dot") is not None:
                    errors.append(['Decode_Error', f])
        print("\r" + "Drawing CFG... " + str(i) + "/" + tasklen, end="", flush=True)
    shutil.rmtree("fixer2038_graphfiles")
    print(" OK")
    return errors

def buildPDG(files):
    """Search references in code represented by this node"""
    for file in files:
        fname = file.ent.name()
        tasklen = str(len(file.functions))
        print("Building PDG...[" + fname + "]", end="", flush=True)
        sortrefs = []
        for r in file.ent.filerefs():
            if not r.isforward():
                sortrefs.append([r.line(), r.column(), r])
        sortrefs.sort(key=operator.itemgetter(0, 1))
        for num, f in enumerate(file.functions, 1):
            visited = []
            tovisit = collections.deque()
            tovisit.append(f.CFGroot)
            while len(tovisit) != 0:
                n = tovisit.popleft()
                visited.append(n)
                for nn in n.nextnode:
                    if (nn not in visited) and (nn not in tovisit):
                        tovisit.append(nn)
                if n.line_begin >= 0 and n.line_end >= 0:
                    deletelist = []
                    for i, r in enumerate(sortrefs):
                        rline = r[0]
                        rcolumn = r[1]
                        if (rline > n.line_end) or ((n.line_end == rline) and (n.column_end < rcolumn)):
                            break
                        elif (n.line_begin <= rline <= n.line_end) and ((n.column_begin <= rcolumn) if (n.line_begin == rline) else True) and ((rcolumn <= n.column_end) if (n.line_end == rline) else True):
                            n.references.append([r[2].scope(), r[2]])
                            deletelist.append(i)
                    if deletelist:
                        del sortrefs[min(deletelist):max(deletelist)+1]
                f.dependTreeMaker()
                print("\r" + "Building PDG...[" + fname + "] " + str(num) + "/" + tasklen, end="", flush=True)
        print("  OK")

def searchTargetFunction(db):
    """Searching exturn functions that need to be fixed"""
    targetlist = ["ctime", "ctime_r", "gmtime", "gmtime_r", "localtime", "localtime_r", "mktime", "timegm", "timelocal", "strftime", "asctime", "time", "asctime_r", "strptime"]
    targetents = []
    for t in targetlist:
        targetents.extend(db.lookup(t))
    return targetents

def fixManager(file, funcstofix, allfuncs, args):
    """Managing fixing ONE file"""
    global logfile
    print("FixManager :", file.ent.name())
    logfile.write("FixManager : " + file.ent.name() + "\n")   # to log
    fn = file.ent.name().rsplit('.', 1)[0]
    if not os.path.isfile("fixer2038_logs" + os.sep + file.ent.name()):
        filelog = open("fixer2038_logs" + os.sep + fn + ".txt", mode='w')
    else:
        index = 2
        while os.path.isfile("fixer2038_logs" + os.sep + fn + "(" + str(index) + ").txt"):
            index = index + 1
        filelog = open("fixer2038_logs" + os.sep + fn + "(" + str(index) + ").txt", mode='w')
    filelog.write(file.path + "\n\n")
    # 時刻を扱う関数に関わる変数の特定
    timevars = listingTimeVars(funcstofix, file, file.lexer)
    # 修正必要箇所の特定
    calltofix = callToFixListMaker(file, funcstofix)
    funcexist = calltofix.pop(0)
    calltofix.sort(key=operator.itemgetter(2, 3))
    comparetofix = compareToFixListMaker(timevars, file.lexer, allfuncs, file)
    comparetofix.sort(key=operator.itemgetter(2, 3))
    # 必要なラッパー関数をwrapperdemandsへ書き込み
    loggingwrappers(funcexist)
    # 修正対象ファイルを読み出し
    with open(file.path, 'r', encoding='utf-8') as fr:
        print("File loading...", end="")
        logfile.write("File loading...")    # to log
        contents = fr.readlines()
        print("OK")
        logfile.write("OK\n") # to log
    # callfixerでincludeの追加があるので先にcomparefixerを実行する
    gaps = [0] * len(contents)  # 修正実行による各行内で生じるずれを記憶するリスト
    contents = compareFixer(comparetofix, file.lexer, contents, gaps, args, filelog)
    contents = callFixer(calltofix, file.lexer, contents, gaps, filelog)
    # 修正対象ファイルに上書き
    with open(file.path, 'w', encoding='utf-8') as fw:
        print("File updating...", end="")
        logfile.write("File updating...")   # to log
        fw.writelines(contents)
        print("OK")
        logfile.write("OK\n")   # to log

def listingTimeVars(funcstofix, file, lexer):
    """Listing variables that should be traced in ONE file"""
    # 各ライブラリ関数の引数・戻り値に存在する時刻情報を追跡対象に加える
    # 引数についてはその宣言箇所（見つからなければ関数の開始箇所）から追跡を行う
    fixedtimevals = []
    for fent in funcstofix:
        calls = fent.refs("Callby")
        if (fname := fent.name()) == "ctime":
            for ref in calls:
                if ref.file() == file.ent:
                    where = file.whereIsHere(ref.line())
                    eme = lexer.lexeme(ref.line(), ref.column())
                    while not(((eent := eme.ent()) is not None) and ("Function" not in eent.kindname()) and (eent.type() is not None) and ("time_t" in eent.type())):
                        eme = eme.next()
                        if (eme is None) or (eme.token() == "Newline"):
                            break
                    if (eme is not None) and (eme.token() != "Newline"):
                        if (defref := eme.ent().ref("Define")) is not None:
                            defline = defref.line()
                            defcolumn = defref.column()
                            fixedtimevals.append(FixedTimeVal(eme.ent(), file.whereIsHere(defline()), None, False, defline, defcolumn))
                        else:
                            fixedtimevals.append(FixedTimeVal(eme.ent(), where, None, False, where.CFGroot.nextnode[0].line_begin, where.CFGroot.nextnode[0].column_begin))
                    eme = lexer.lexeme(ref.line(), ref.column())
                    while not(((eent := eme.ent()) is not None) and ("Function" not in eent.kindname()) and (eent.type() is not None) and ("char" in eent.type())):
                        eme = eme.previous()
                        if (eme is None) or (eme.token() == "Newline"):
                            break
                    if (eme is not None) and (eme.token() != "Newline"):
                        fixedtimevals.append(FixedTimeVal(eme.ent(), where, None, False, eme.line_begin(), eme.column_begin()))
        elif fname == "ctime_r":
            for ref in calls:
                if ref.file() == file.ent:
                    where = file.whereIsHere(ref.line())
                    eme = lexer.lexeme(ref.line(), ref.column())
                    while not(((eent := eme.ent()) is not None) and ("Function" not in eent.kindname()) and (eent.type() is not None) and ("time_t" in eent.type())):
                        eme = eme.next()
                        if (eme is None) or (eme.token() == "Newline"):
                            break
                    if (eme is not None) and (eme.token() != "Newline"):
                        if (defref := eme.ent().ref("Define")) is not None:
                            defline = defref.line()
                            defcolumn = defref.column()
                            fixedtimevals.append(FixedTimeVal(eme.ent(), file.whereIsHere(defline()), None, False, defline, defcolumn))
                        else:
                            fixedtimevals.append(FixedTimeVal(eme.ent(), where, None, False, where.CFGroot.nextnode[0].line_begin, where.CFGroot.nextnode[0].column_begin))
                    eme = lexer.lexeme(ref.line(), ref.column())
                    while not(((eent := eme.ent()) is not None) and ("Function" not in eent.kindname()) and (eent.type() is not None) and ("char" in eent.type())):
                        eme = eme.next()
                        if (eme is None) or (eme.token() == "Newline"):
                            break
                    if (eme is not None) and (eme.token() != "Newline"):
                        if (defref := eme.ent().ref("Define")) is not None:
                            defline = defref.line()
                            defcolumn = defref.column()
                            fixedtimevals.append(FixedTimeVal(eme.ent(), file.whereIsHere(defline()), None, False, defline, defcolumn))
                        else:
                            fixedtimevals.append(FixedTimeVal(eme.ent(), where, None, False, where.CFGroot.nextnode[0].line_begin, where.CFGroot.nextnode[0].column_begin))
                    eme = lexer.lexeme(ref.line(), ref.column())
                    while not(((eent := eme.ent()) is not None) and ("Function" not in eent.kindname()) and (eent.type() is not None) and ("char" in eent.type())):
                        eme = eme.previous()
                        if (eme is None) or (eme.token() == "Newline"):
                            break
                    if (eme is not None) and (eme.token() != "Newline"):
                        fixedtimevals.append(FixedTimeVal(eme.ent(), where, None, False, eme.line_begin(), eme.column_begin()))
        elif fname == "gmtime":
            for ref in calls:
                if ref.file() == file.ent:
                    where = file.whereIsHere(ref.line())
                    eme = lexer.lexeme(ref.line(), ref.column())
                    while not(((eent := eme.ent()) is not None) and ("Function" not in eent.kindname()) and (eent.type() is not None) and ("time_t" in eent.type())):
                        eme = eme.next()
                        if (eme is None) or (eme.token() == "Newline"):
                            break
                    if (eme is not None) and (eme.token() != "Newline"):
                        if (defref := eme.ent().ref("Define")) is not None:
                            defline = defref.line()
                            defcolumn = defref.column()
                            fixedtimevals.append(FixedTimeVal(eme.ent(), file.whereIsHere(defline()), None, False, defline, defcolumn))
                        else:
                            fixedtimevals.append(FixedTimeVal(eme.ent(), where, None, False, where.CFGroot.nextnode[0].line_begin, where.CFGroot.nextnode[0].column_begin))
                    eme = lexer.lexeme(ref.line(), ref.column())
                    while not(((eent := eme.ent()) is not None) and ("Function" not in eent.kindname()) and (eent.type() is not None) and ("struct tm" in eent.type())):
                        eme = eme.previous()
                        if (eme is None) or (eme.token() == "Newline"):
                            break
                    if (eme is not None) and (eme.token() != "Newline"):
                        fixedtimevals.append(FixedTimeVal(eme.ent(), where, "tm_year", True, eme.line_begin(), eme.column_begin()))
        elif fname == "gmtime_r":
            for ref in calls:
                if ref.file() == file.ent:
                    where = file.whereIsHere(ref.line())
                    eme = lexer.lexeme(ref.line(), ref.column())
                    while not(((eent := eme.ent()) is not None) and ("Function" not in eent.kindname()) and (eent.type() is not None) and ("time_t" in eent.type())):
                        eme = eme.next()
                        if (eme is None) or (eme.token() == "Newline"):
                            break
                    if (eme is not None) and (eme.token() != "Newline"):
                        if (defref := eme.ent().ref("Define")) is not None:
                            defline = defref.line()
                            defcolumn = defref.column()
                            fixedtimevals.append(FixedTimeVal(eme.ent(), file.whereIsHere(defline()), None, False, defline, defcolumn))
                        else:
                            fixedtimevals.append(FixedTimeVal(eme.ent(), where, None, False, where.CFGroot.nextnode[0].line_begin, where.CFGroot.nextnode[0].column_begin))
                    eme = lexer.lexeme(ref.line(), ref.column())
                    while not(((eent := eme.ent()) is not None) and ("Function" not in eent.kindname()) and (eent.type() is not None) and ("struct tm" in eent.type())):
                        eme = eme.next()
                        if (eme is None) or (eme.token() == "Newline"):
                            break
                    if (eme is not None) and (eme.token() != "Newline"):
                        if (defref := eme.ent().ref("Define")) is not None:
                            defline = defref.line()
                            defcolumn = defref.column()
                            fixedtimevals.append(FixedTimeVal(eme.ent(), file.whereIsHere(defline()), "tm_year", True, defline, defcolumn))
                        else:
                            fixedtimevals.append(FixedTimeVal(eme.ent(), where, "tm_year", True, where.CFGroot.nextnode[0].line_begin, where.CFGroot.nextnode[0].column_begin))
                    eme = lexer.lexeme(ref.line(), ref.column())
                    while not(((eent := eme.ent()) is not None) and ("Function" not in eent.kindname()) and (eent.type() is not None) and ("struct tm" in eent.type())):
                        eme = eme.previous()
                        if (eme is None) or (eme.token() == "Newline"):
                            break
                    if (eme is not None) and (eme.token() != "Newline"):
                        fixedtimevals.append(FixedTimeVal(eme.ent(), where, "tm_year", True, eme.line_begin(), eme.column_begin()))
        elif fname == "localtime":
            for ref in calls:
                if ref.file() == file.ent:
                    where = file.whereIsHere(ref.line())
                    eme = lexer.lexeme(ref.line(), ref.column())
                    while not(((eent := eme.ent()) is not None) and ("Function" not in eent.kindname()) and (eent.type() is not None) and ("time_t" in eent.type())):
                        eme = eme.next()
                        if (eme is None) or (eme.token() == "Newline"):
                            break
                    if (eme is not None) and (eme.token() != "Newline"):
                        if (defref := eme.ent().ref("Define")) is not None:
                            defline = defref.line()
                            defcolumn = defref.column()
                            fixedtimevals.append(FixedTimeVal(eme.ent(), file.whereIsHere(defline()), None, False, defline, defcolumn))
                        else:
                            fixedtimevals.append(FixedTimeVal(eme.ent(), where, None, False, where.CFGroot.nextnode[0].line_begin, where.CFGroot.nextnode[0].column_begin))
                    eme = lexer.lexeme(ref.line(), ref.column())
                    while not(((eent := eme.ent()) is not None) and ("Function" not in eent.kindname()) and (eent.type() is not None) and ("struct tm" in eent.type())):
                        eme = eme.previous()
                        if (eme is None) or (eme.token() == "Newline"):
                            break
                    if (eme is not None) and (eme.token() != "Newline"):
                        fixedtimevals.append(FixedTimeVal(eme.ent(), where, "tm_year", True, eme.line_begin(), eme.column_begin()))
        elif fname == "localtime_r":
            for ref in calls:
                if ref.file() == file.ent:
                    where = file.whereIsHere(ref.line())
                    eme = lexer.lexeme(ref.line(), ref.column())
                    while not(((eent := eme.ent()) is not None) and ("Function" not in eent.kindname()) and (eent.type() is not None) and ("time_t" in eent.type())):
                        eme = eme.next()
                        if (eme is None) or (eme.token() == "Newline"):
                            break
                    if (eme is not None) and (eme.token() != "Newline"):
                        if (defref := eme.ent().ref("Define")) is not None:
                            defline = defref.line()
                            defcolumn = defref.column()
                            fixedtimevals.append(FixedTimeVal(eme.ent(), file.whereIsHere(defline()), None, False, defline, defcolumn))
                        else:
                            fixedtimevals.append(FixedTimeVal(eme.ent(), where, None, False, where.CFGroot.nextnode[0].line_begin, where.CFGroot.nextnode[0].column_begin))
                    eme = lexer.lexeme(ref.line(), ref.column())
                    while not(((eent := eme.ent()) is not None) and ("Function" not in eent.kindname()) and (eent.type() is not None) and ("struct tm" in eent.type())):
                        eme = eme.next()
                        if (eme is None) or (eme.token() == "Newline"):
                            break
                    if (eme is not None) and (eme.token() != "Newline"):
                        if (defref := eme.ent().ref("Define")) is not None:
                            defline = defref.line()
                            defcolumn = defref.column()
                            fixedtimevals.append(FixedTimeVal(eme.ent(), file.whereIsHere(defline()), "tm_year", True, defline, defcolumn))
                        else:
                            fixedtimevals.append(FixedTimeVal(eme.ent(), where, "tm_year", True, where.CFGroot.nextnode[0].line_begin, where.CFGroot.nextnode[0].column_begin))
                    eme = lexer.lexeme(ref.line(), ref.column())
                    while not(((eent := eme.ent()) is not None) and ("Function" not in eent.kindname()) and (eent.type() is not None) and ("struct tm" in eent.type())):
                        eme = eme.previous()
                        if (eme is None) or (eme.token() == "Newline"):
                            break
                    if (eme is not None) and (eme.token() != "Newline"):
                        fixedtimevals.append(FixedTimeVal(eme.ent(), where, "tm_year", True, eme.line_begin(), eme.column_begin()))
        elif fname == "mktime":
            for ref in calls:
                if ref.file() == file.ent:
                    where = file.whereIsHere(ref.line())
                    eme = lexer.lexeme(ref.line(), ref.column())
                    while not(((eent := eme.ent()) is not None) and ("Function" not in eent.kindname()) and (eent.type() is not None) and ("struct tm" in eent.type())):
                        eme = eme.next()
                        if (eme is None) or (eme.token() == "Newline"):
                            break
                    if (eme is not None) and (eme.token() != "Newline"):
                        if (defref := eme.ent().ref("Define")) is not None:
                            defline = defref.line()
                            defcolumn = defref.column()
                            fixedtimevals.append(FixedTimeVal(eme.ent(), file.whereIsHere(defline()), "tm_year", True, defline, defcolumn))
                        else:
                            fixedtimevals.append(FixedTimeVal(eme.ent(), where, "tm_year", True, where.CFGroot.nextnode[0].line_begin, where.CFGroot.nextnode[0].column_begin))
                    eme = lexer.lexeme(ref.line(), ref.column())
                    while not(((eent := eme.ent()) is not None) and ("Function" not in eent.kindname()) and (eent.type() is not None) and ("time_t" in eent.type())):
                        eme = eme.previous()
                        if (eme is None) or (eme.token() == "Newline"):
                            break
                    if (eme is not None) and (eme.token() != "Newline"):
                        fixedtimevals.append(FixedTimeVal(eme.ent(), where, None, False, eme.line_begin(), eme.column_begin()))
        elif fname == "strftime":
            for ref in calls:
                if ref.file() == file.ent:
                    where = file.whereIsHere(ref.line())
                    eme = lexer.lexeme(ref.line(), ref.column())
                    while not(((eent := eme.ent()) is not None) and ("Function" not in eent.kindname()) and (eent.type() is not None) and ("char" in eent.type())):
                        eme = eme.next()
                        if (eme is None) or (eme.token() == "Newline"):
                            break
                    if (eme is not None) and (eme.token() != "Newline"):
                        if (defref := eme.ent().ref("Define")) is not None:
                            defline = defref.line()
                            defcolumn = defref.column()
                            fixedtimevals.append(FixedTimeVal(eme.ent(), file.whereIsHere(defline()), None, False, defline, defcolumn))
                        else:
                            fixedtimevals.append(FixedTimeVal(eme.ent(), where, None, False, where.CFGroot.nextnode[0].line_begin, where.CFGroot.nextnode[0].column_begin))
                    eme = lexer.lexeme(ref.line(), ref.column())
                    while not(((eent := eme.ent()) is not None) and ("Function" not in eent.kindname()) and (eent.type() is not None) and ("struct tm" in eent.type())):
                        eme = eme.next()
                        if (eme is None) or (eme.token() == "Newline"):
                            break
                    if (eme is not None) and (eme.token() != "Newline"):
                        if (defref := eme.ent().ref("Define")) is not None:
                            defline = defref.line()
                            defcolumn = defref.column()
                            fixedtimevals.append(FixedTimeVal(eme.ent(), file.whereIsHere(defline()), "tm_year", True, defline, defcolumn))
                        else:
                            fixedtimevals.append(FixedTimeVal(eme.ent(), where, "tm_year", True, where.CFGroot.nextnode[0].line_begin, where.CFGroot.nextnode[0].column_begin))
        elif fname == "timegm":
            for ref in calls:
                if ref.file() == file.ent:
                    where = file.whereIsHere(ref.line())
                    eme = lexer.lexeme(ref.line(), ref.column())
                    while not(((eent := eme.ent()) is not None) and ("Function" not in eent.kindname()) and (eent.type() is not None) and ("struct tm" in eent.type())):
                        eme = eme.next()
                        if (eme is None) or (eme.token() == "Newline"):
                            break
                    if (eme is not None) and (eme.token() != "Newline"):
                        if (defref := eme.ent().ref("Define")) is not None:
                            defline = defref.line()
                            defcolumn = defref.column()
                            fixedtimevals.append(FixedTimeVal(eme.ent(), file.whereIsHere(defline()), "tm_year", True, defline, defcolumn))
                        else:
                            fixedtimevals.append(FixedTimeVal(eme.ent(), where, "tm_year", True, where.CFGroot.nextnode[0].line_begin, where.CFGroot.nextnode[0].column_begin))
                    eme = lexer.lexeme(ref.line(), ref.column())
                    while not(((eent := eme.ent()) is not None) and ("Function" not in eent.kindname()) and (eent.type() is not None) and ("time_t" in eent.type())):
                        eme = eme.previous()
                        if (eme is None) or (eme.token() == "Newline"):
                            break
                    if (eme is not None) and (eme.token() != "Newline"):
                        fixedtimevals.append(FixedTimeVal(eme.ent(), where, None, False, eme.line_begin(), eme.column_begin()))
        elif fname == "timelocal":
            for ref in calls:
                if ref.file() == file.ent:
                    where = file.whereIsHere(ref.line())
                    eme = lexer.lexeme(ref.line(), ref.column())
                    while not(((eent := eme.ent()) is not None) and ("Function" not in eent.kindname()) and (eent.type() is not None) and ("struct tm" in eent.type())):
                        eme = eme.next()
                        if (eme is None) or (eme.token() == "Newline"):
                            break
                    if (eme is not None) and (eme.token() != "Newline"):
                        if (defref := eme.ent().ref("Define")) is not None:
                            defline = defref.line()
                            defcolumn = defref.column()
                            fixedtimevals.append(FixedTimeVal(eme.ent(), file.whereIsHere(defline()), "tm_year", True, defline, defcolumn))
                        else:
                            fixedtimevals.append(FixedTimeVal(eme.ent(), where, "tm_year", True, where.CFGroot.nextnode[0].line_begin, where.CFGroot.nextnode[0].column_begin))
                    eme = lexer.lexeme(ref.line(), ref.column())
                    while not(((eent := eme.ent()) is not None) and ("Function" not in eent.kindname()) and (eent.type() is not None) and ("time_t" in eent.type())):
                        eme = eme.previous()
                        if (eme is None) or (eme.token() == "Newline"):
                            break
                    if (eme is not None) and (eme.token() != "Newline"):
                        fixedtimevals.append(FixedTimeVal(eme.ent(), where, None, False, eme.line_begin(), eme.column_begin()))
        elif fname == "asctime":
            for ref in calls:
                if ref.file() == file.ent:
                    where = file.whereIsHere(ref.line())
                    eme = lexer.lexeme(ref.line(), ref.column())
                    while not(((eent := eme.ent()) is not None) and ("Function" not in eent.kindname()) and (eent.type() is not None) and ("struct tm" in eent.type())):
                        eme = eme.next()
                        if (eme is None) or (eme.token() == "Newline"):
                            break
                    if (eme is not None) and (eme.token() != "Newline"):
                        if (defref := eme.ent().ref("Define")) is not None:
                            defline = defref.line()
                            defcolumn = defref.column()
                            fixedtimevals.append(FixedTimeVal(eme.ent(), file.whereIsHere(defline()), "tm_year", True, defline, defcolumn))
                        else:
                            fixedtimevals.append(FixedTimeVal(eme.ent(), where, "tm_year", True, where.CFGroot.nextnode[0].line_begin, where.CFGroot.nextnode[0].column_begin))
                    eme = lexer.lexeme(ref.line(), ref.column())
                    while not(((eent := eme.ent()) is not None) and ("Function" not in eent.kindname()) and (eent.type() is not None) and ("char" in eent.type())):
                        eme = eme.previous()
                        if (eme is None) or (eme.token() == "Newline"):
                            break
                    if (eme is not None) and (eme.token() != "Newline"):
                        fixedtimevals.append(FixedTimeVal(eme.ent(), where, None, False, eme.line_begin(), eme.column_begin()))
        elif fname == "time":
            for ref in calls:
                if ref.file() == file.ent:
                    where = file.whereIsHere(ref.line())
                    eme = lexer.lexeme(ref.line(), ref.column())
                    while not(((eent := eme.ent()) is not None) and ("Function" not in eent.kindname()) and (eent.type() is not None) and ("time_t" in eent.type())):
                        eme = eme.next()
                        if (eme is None) or (eme.text() == ")"):
                            break
                    if (eme is not None) and (eme.text() != ")"):
                        if (defref := eme.ent().ref("Define")) is not None:
                            defline = defref.line()
                            defcolumn = defref.column()
                            fixedtimevals.append(FixedTimeVal(eme.ent(), file.whereIsHere(defline()), None, False, defline, defcolumn))
                        else:
                            fixedtimevals.append(FixedTimeVal(eme.ent(), where, None, False, where.CFGroot.nextnode[0].line_begin, where.CFGroot.nextnode[0].column_begin))
                    eme = lexer.lexeme(ref.line(), ref.column())
                    while not(((eent := eme.ent()) is not None) and ("Function" not in eent.kindname()) and (eent.type() is not None) and ("time_t" in eent.type())):
                        eme = eme.previous()
                        if (eme is None) or (eme.token() == "Newline"):
                            break
                    if (eme is not None) and (eme.token() != "Newline"):
                        fixedtimevals.append(FixedTimeVal(eme.ent(), where, None, False, eme.line_begin(), eme.column_begin()))
        elif fname == "asctime_r":
            for ref in calls:
                if ref.file() == file.ent:
                    where = file.whereIsHere(ref.line())
                    eme = lexer.lexeme(ref.line(), ref.column())
                    while not(((eent := eme.ent()) is not None) and ("Function" not in eent.kindname()) and (eent.type() is not None) and ("struct tm" in eent.type())):
                        eme = eme.next()
                        if (eme is None) or (eme.token() == "Newline"):
                            break
                    if (eme is not None) and (eme.token() != "Newline"):
                        if (defref := eme.ent().ref("Define")) is not None:
                            defline = defref.line()
                            defcolumn = defref.column()
                            fixedtimevals.append(FixedTimeVal(eme.ent(), file.whereIsHere(defline()), "tm_year", True, defline, defcolumn))
                        else:
                            fixedtimevals.append(FixedTimeVal(eme.ent(), where, "tm_year", True, where.CFGroot.nextnode[0].line_begin, where.CFGroot.nextnode[0].column_begin))
                    eme = lexer.lexeme(ref.line(), ref.column())
                    while not(((eent := eme.ent()) is not None) and ("Function" not in eent.kindname()) and (eent.type() is not None) and ("char" in eent.type())):
                        eme = eme.next()
                        if (eme is None) or (eme.token() == "Newline"):
                            break
                    if (eme is not None) and (eme.token() != "Newline"):
                        if (defref := eme.ent().ref("Define")) is not None:
                            defline = defref.line()
                            defcolumn = defref.column()
                            fixedtimevals.append(FixedTimeVal(eme.ent(), file.whereIsHere(defline()), None, False, defline, defcolumn))
                        else:
                            fixedtimevals.append(FixedTimeVal(eme.ent(), where, None, False, where.CFGroot.nextnode[0].line_begin, where.CFGroot.nextnode[0].column_begin))
                    eme = lexer.lexeme(ref.line(), ref.column())
                    while not(((eent := eme.ent()) is not None) and ("Function" not in eent.kindname()) and (eent.type() is not None) and ("char" in eent.type())):
                        eme = eme.previous()
                        if (eme is None) or (eme.token() == "Newline"):
                            break
                    if (eme is not None) and (eme.token() != "Newline"):
                        fixedtimevals.append(FixedTimeVal(eme.ent(), where, None, False, eme.line_begin(), eme.column_begin()))
        elif fname == "strptime":
            for ref in calls:
                if ref.file() == file.ent:
                    where = file.whereIsHere(ref.line())
                    eme = lexer.lexeme(ref.line(), ref.column())
                    while not(((eent := eme.ent()) is not None) and ("Function" not in eent.kindname()) and (eent.type() is not None) and ("char" in eent.type())):
                        eme = eme.next()
                        if (eme is None) or (eme.token() == "Newline"):
                            break
                    if (eme is not None) and (eme.token() != "Newline"):
                        if (defref := eme.ent().ref("Define")) is not None:
                            defline = defref.line()
                            defcolumn = defref.column()
                            fixedtimevals.append(FixedTimeVal(eme.ent(), file.whereIsHere(defline()), None, False, defline, defcolumn))
                        else:
                            fixedtimevals.append(FixedTimeVal(eme.ent(), where, None, False, where.CFGroot.nextnode[0].line_begin, where.CFGroot.nextnode[0].column_begin))
                    eme = lexer.lexeme(ref.line(), ref.column())
                    while not(((eent := eme.ent()) is not None) and ("Function" not in eent.kindname()) and (eent.type() is not None) and ("struct tm" in eent.type())):
                        eme = eme.next()
                        if (eme is None) or (eme.token() == "Newline"):
                            break
                    if (eme is not None) and (eme.token() != "Newline"):
                        if (defref := eme.ent().ref("Define")) is not None:
                            defline = defref.line()
                            defcolumn = defref.column()
                            fixedtimevals.append(FixedTimeVal(eme.ent(), file.whereIsHere(defline()), "tm_year", True, defline, defcolumn))
                        else:
                            fixedtimevals.append(FixedTimeVal(eme.ent(), where, "tm_year", True, where.CFGroot.nextnode[0].line_begin, where.CFGroot.nextnode[0].column_begin))
    return fixedtimevals

# def whereIsHere(file, line, funcs):
#     """Detect Function from Line number"""
#     for f in funcs:
#         if (f.declaredfile == file) and (f.line_begin <= line) and (line <= f.line_end):
#             return f
#     return None

def callToFixListMaker(file, funcs):
    """Listing calling point should be fixed in ONE file"""
    calltofix = []
    # calltofix[0]：wrapperdemands上書き用情報の受け渡しに用いる
    calltofix.append([0, 0, 0, 0, 0, 0, 0, 0, 0])
    for fent in funcs:
        calls = fent.refs("Callby")
        for ref in calls:
            if ref.file() == file.ent:
                duplicated = False
                for exist in calltofix[1:]:
                    if (exist[0].line() == ref.line()) and (exist[0].column() == ref.column()):
                        duplicated = True
                if not duplicated:
                    if (fname := fent.name()) == "ctime":
                        calltofix[0][0] = 1
                        calltofix.append([ref, "ctime", ref.line(), ref.column()])
                    elif fname == "ctime_r":
                        calltofix[0][1] = 1
                        calltofix.append([ref, "ctime_r", ref.line(), ref.column()])
                    elif fname == "gmtime":
                        calltofix[0][2] = 1
                        calltofix.append([ref, "gmtime", ref.line(), ref.column()])
                    elif fname == "gmtime_r":
                        calltofix[0][3] = 1
                        calltofix.append([ref, "gmtime_r", ref.line(), ref.column()])
                    elif fname == "localtime":
                        calltofix[0][4] = 1
                        calltofix.append([ref, "localtime", ref.line(), ref.column()])
                    elif fname == "localtime_r":
                        calltofix[0][5] = 1
                        calltofix.append([ref, "localtime_r", ref.line(), ref.column()])
                    elif fname == "mktime":
                        calltofix[0][6] = 1
                        calltofix.append([ref, "mktime", ref.line(), ref.column()])
                    elif fname == "timegm":
                        calltofix[0][7] = 1
                        calltofix.append([ref, "timegm", ref.line(), ref.column()])
                    elif fname == "timelocal":
                        calltofix[0][8] = 1
                        calltofix.append([ref, "timelocal", ref.line(), ref.column()])
    return calltofix

def compareToFixListMaker(targets, lexer, funcs, file):
    """Listing comparing point should be fixed in ONE file"""
    comparetofix = []
    tracked = []
    compareoperation = ["==", "<", ">", "<=", ">=", "!="]
    assignoperation = ["=", "+=", "-=", "*=", "/=", "%="]
    logicaloperation = ["&&", "||", "!"]
    spacetokens = ["Whitespace", "Indent", "Dedent"]
    while targets:
        # 1つの変数の追跡
        tv = targets.pop()
        tracked.append(tv)
        if tv.function is not None:
            # 追跡開始地点のnodeを探索対象リストの初期値とする
            start = nodeSearcher(tv.startingpoint, tv.function.CFGroot)
            tovisit = collections.deque()
            tovisit.append(start)
            visited = []
            # 追跡
            while tovisit:
                nocontinue = False
                # tovisitからノードを1つ取り出してvisitedへ
                node = tovisit.pop()
                visited.append(node.metanum)
                # ノード内で追跡中変数のリファレンスがあるか
                for r in node.references:
                    if r[0] == tv.ent:
                        token = lexer.lexeme(r[1].line(), r[1].column())
                        nexttoken = token.next()
                        prevtoken = token.previous()
                        if tv.ismember:
                            tmptoken = token.next()
                            while (tmptoken is not None) and ((tmptoken.text() in ["->", ".", "*", "&"]) or (tmptoken.token() in ["Whitespace", "Indent", "Dedent"])):
                                tmptoken = tmptoken.next()
                            if (tmptoken is None) or ((tmptoken.text() != tv.memname) and (tmptoken.token() == "Identifier")):  # 構造体のメンバ一致確認
                                continue
                            elif tmptoken.text() == tv.memname:
                                nexttoken = tmptoken.next()
                            else:
                                nexttoken = token.next()
                        # Useリファレンスは比較・代入に関わるため内容確認
                        if ("Use" in (rkind := r[1].kindname())) or ((tv.ent.kindname() == "Function") and ("Call" in r[1].kindname()) and (not r[1].isforward())):
                            # 1. prevtokenを辿り、最初の左括弧の次に関数名があるかを調べる（引数利用の確認）
                            brackets = 0
                            number = 1
                            functionuse = False
                            while (prevtoken is not None) and ((prevkind := prevtoken.token()) != "Newline") and (prevkind != "Keyword") and ((prevtext := prevtoken.text()) not in logicaloperation):
                                if (prevtext == "("):
                                    if brackets <= 0:
                                        pprev = prevtoken.previous()
                                        while (pprev is not None) and (pprev.token() in spacetokens):
                                            pprev = pprev.previous()
                                        if (pprev is not None) and (pprev.ent() is not None) and ("Function" in pprev.ent().kindname()):
                                            functionuse = True
                                            # ファイル内宣言関数か確認
                                            for f in funcs:
                                                if (f.obj == pprev.ent()):
                                                    if (f.declaredfile is not None) and (f.declaredfile == node.parent.declaredfile):
                                                        # ファイル内宣言関数なら引数の対応付けを行い、追跡対象に追加
                                                        defeme = lexer.lexeme(f.obj.ref("Definein").line(), f.obj.ref("Definein").column())
                                                        while defeme.text() != "(" :
                                                            defeme = defeme.next()
                                                        brackets = 0
                                                        puncs = [",", ")"]
                                                        memory = defeme.next()
                                                        while number > 0 :
                                                            if ((nextext := defeme.next().text()) in puncs) and (brackets == 0):
                                                                number = number - 1
                                                            elif nextext == "(" :
                                                                brackets = brackets + 1
                                                            elif nextext == ")" :
                                                                brackets = brackets - 1
                                                            elif (nextext == "...") and (brackets == 0):
                                                                memory = defeme.next()
                                                                break
                                                            elif brackets == 0:
                                                                memory = defeme.next()
                                                            defeme = defeme.next()
                                                        exist = False
                                                        if memory.ent() is not None:
                                                            for t in targets:
                                                                if (t.ent == memory.ent()) and (t.startingpoint == memory.line_begin()):
                                                                    exist = True
                                                                    break
                                                            if not exist:
                                                                for t in tracked:
                                                                    if (t.ent == memory.ent()) and (t.startingpoint == memory.line_begin()):
                                                                        exist = True
                                                                        break
                                                            if not exist:
                                                                targets.append(FixedTimeVal(memory.ent(), file.whereIsHere(memory.line_begin()), tv.memname, tv.isyear, memory.line_begin(), memory.column_begin()))
                                                        else:   # 可変長引数への対応
                                                            while (memory.ent() is None) or (memory.ent().type() is None) or (memory.ent().type() != "va_list"):
                                                                memory = memory.next()
                                                            vadef = memory.ent().refs("definein")[0]
                                                            if vadef is not None:
                                                                for t in targets:
                                                                    if t.startingpoint == vadef.line():
                                                                        exist = True
                                                                        break
                                                                if not exist:
                                                                    for t in tracked:
                                                                        if t.startingpoint == vadef.line():
                                                                            exist = True
                                                                            break
                                                                if not exist:
                                                                    targets.append(FixedTimeVal(memory.ent(), file.whereIsHere(memory.line_begin()), tv.memname, "unknown", vadef.line(), vadef.column()))
                                                    else:
                                                        # それ以外なら戻り値を追跡対象に追加
                                                        exist = False
                                                        ppp = pprev.previous()
                                                        while (ppp is not None) and (ppp.token() not in ["Newline", "Keyword", "EndOfStatement"]):
                                                            if (ppp.text() in assignoperation):
                                                                while (ppp is not None) and (ppp.token() != "Identifier"):
                                                                    ppp = ppp.previous()
                                                                if ppp is not None:
                                                                    pppp = ppp.previous()
                                                                    while (pppp is not None) and (pppp.token() in spacetokens):
                                                                        pppp = pppp.previous()
                                                                    if (pppp is not None) and (pppp.text() in [".", "->"]):
                                                                        while (pppp is not None) and (pppp.token() != "Identifier"):
                                                                            pppp = pppp.previous()
                                                                        for t in targets:
                                                                            if (t.ent == pppp.ent()) and (t.startingpoint == pppp.line_begin()):
                                                                                exist = True
                                                                                break
                                                                        if not exist:
                                                                            for t in tracked:
                                                                                if (t.ent == pppp.ent()) and (t.startingpoint == pppp.line_begin()):
                                                                                    exist = True
                                                                                    break
                                                                        if not exist:
                                                                            targets.append(FixedTimeVal(pppp.ent(), tv.function, ppp.text(), "Unknown", pppp.line_begin(), pppp.column_begin()))
                                                                    else:
                                                                        for t in targets:
                                                                            if (t.ent == ppp.ent()) and (t.startingpoint == ppp.line_begin()):
                                                                                exist = True
                                                                                break
                                                                        if not exist:
                                                                            for t in tracked:
                                                                                if (t.ent == ppp.ent()) and (t.startingpoint == ppp.line_begin()):
                                                                                    exist = True
                                                                                    break
                                                                        if not exist:
                                                                            targets.append(FixedTimeVal(ppp.ent(), tv.function, None, "Unknown", ppp.line_begin(), ppp.column_begin()))
                                                                break
                                                            ppp = ppp.previous()
                                        break
                                    else:
                                        brackets = brackets - 1
                                elif (prevtext == ")"):
                                    brackets = brackets + 1
                                elif (prevtext == ","):
                                    number = number + 1
                                prevtoken = prevtoken.previous()
                            # 2. 前後に外側の（前なら右括弧、後ろは左括弧）括弧の数を数えながら辿り、キーワードや論理演算子、比較代入演算子に行きつくまでの括弧の階層を調べる
                            rightbrackets = 0
                            leftbrackets = 0
                            nexttoken = token.next()
                            prevtoken = token.previous()
                            # rightbrackets < 0 のときの演算子はtvの参照に関係しない
                            while (nexttoken is not None) and (nexttoken.token() not in ["Keyword", "Newline", "EndOfStatement"]) and ((rightbrackets < 0) or (((nexttext := nexttoken.text()) not in logicaloperation) and (nexttext not in assignoperation) and (nexttext not in compareoperation))):
                                if nexttext == ")":
                                    rightbrackets = rightbrackets + 1
                                elif nexttext == "(":
                                    rightbrackets = rightbrackets - 1
                                nexttoken = nexttoken.next()
                            while (prevtoken is not None) and (prevtoken.token() not in ["Keyword", "Newline", "EndOfStatement"]) and ((leftbrackets < 0) or (((prevtext := prevtoken.text()) not in logicaloperation) and (prevtext not in assignoperation) and (prevtext not in compareoperation))):
                                if prevtext == "(":
                                    leftbrackets = leftbrackets + 1
                                elif prevtext == ")":
                                    leftbrackets = leftbrackets - 1
                                prevtoken = prevtoken.previous()
                            # 3. 両方に比較・代入演算子があった場合、括弧が少ない方の演算子を優先して処理。代入の場合これによってtvが増えるので、代入先の比較は後で拾える
                            # より内側に比較がある場合、その値は真理値になるので、外側の比較演算子は修正しなくてよい
                            if ((nexttoken is not None) and (nexttoken.token() == "Operator") and (nexttext not in logicaloperation)) and ((prevtoken is not None) and (prevtoken.token() == "Operator") and (prevtext not in logicaloperation)):
                                if rightbrackets > leftbrackets:
                                    nexttoken = None
                                elif leftbrackets > rightbrackets:
                                    prevtoken = None
                                if functionuse and (leftbrackets > 0):
                                    # 引数利用の場合、関数呼び出しの外側の演算子は関係ない
                                    prevtoken = None
                            if nexttoken is not None:
                                if nexttext in compareoperation:    # 比較
                                    nnext = nexttoken.next()
                                    while (nnext.token() in spacetokens):
                                        nnext = nnext.next()
                                    if nnext.text().lower() != "null":
                                        comparetofix.append([r[1], tv, nexttoken.line_begin(), nexttoken.column_begin()])
                                elif nexttext in assignoperation:   # 他への代入は前方には存在しえない
                                    pass
                            if prevtoken is not None:
                                if prevtext in compareoperation:    # 比較
                                    pprev = prevtoken.previous()
                                    while (pprev.token() in spacetokens):
                                        pprev = pprev.previous()
                                    if pprev.text().lower() != "null":
                                        comparetofix.append([r[1], tv, prevtoken.line_begin(), prevtoken.column_begin()])
                                elif prevtext in assignoperation:   # 他への代入
                                    pprev = prevtoken.previous()
                                    while (pprev is not None) and (pprev.token() != "Identifier"):
                                        pprev = pprev.previous()
                                    if pprev is not None:
                                        # 構造体のメンバかを確認
                                        ppp = pprev.previous()
                                        while (ppp is not None) and (ppp.token() in spacetokens):
                                            ppp = ppp.previous()
                                        if (ppp is not None) and (ppp.text() in [".", "->"]):
                                            while (ppp is not None) and (ppp.token() != "Identifier"):
                                                ppp = ppp.previous()
                                            if ppp is not None:
                                                exist = False
                                                for t in targets:
                                                    if (t.ent == ppp.ent()) and (t.startingpoint == r[1].line()):
                                                        exist = True
                                                        break
                                                if not exist:
                                                    for t in tracked:
                                                        if (t.ent == ppp.ent()) and (t.startingpoint == r[1].line()):
                                                            exist = True
                                                            break
                                                if not exist:
                                                    targets.append(FixedTimeVal(ppp.ent(), tv.function, pprev.text(), tv.isyear, r[1].line(), r[1].column()))
                                        else:
                                            exist = False
                                            for t in targets:
                                                if (t.ent == pprev.ent()) and (t.startingpoint == r[1].line()):
                                                    exist = True
                                                    break
                                            if not exist:
                                                for t in tracked:
                                                    if (t.ent == pprev.ent()) and (t.startingpoint == r[1].line()):
                                                        exist = True
                                                        break
                                            if not exist:
                                                if (tv.type is not None) and ("struct" in tv.type) and (pprev.ent().type() is not None) and (tv.type == pprev.ent().type()):
                                                    targets.append(FixedTimeVal(pprev.ent(), tv.function, tv.memname, tv.isyear, r[1].line(), r[1].column()))
                                                else:
                                                    targets.append(FixedTimeVal(pprev.ent(), tv.function, None, tv.isyear, r[1].line(), r[1].column()))
                        # setかmodiifyなら右辺に使用されている変数を追跡対象とする
                        elif ("Set" in rkind) or ("Modify" in rkind):
                            # 1. nexttokenを辿り、括弧の階層0以上でキーワードか論理演算子が出るまでに出てきた識別子を追跡対象に
                            brackets = 0
                            while (nexttoken is not None) and ((brackets > 0) or (((nextkind := nexttoken.token()) != "Keyword") and ((nexttext := nexttoken.text()) not in logicaloperation))):
                                if nexttext == "(":
                                    brackets = brackets + 1
                                elif nexttext == ")":
                                    brackets = brackets - 1
                                elif (nextkind == "Identifier") and (nexttext.upper() != "NULL") and ((nextent := nexttoken.ent()) is not None):
                                    if ((defref := nextent.ref("Define")) is not None) and ("Function" not in nextent.kindname()):
                                        tvline = defref.line()
                                        tvcolumn = defref.column()
                                    else:
                                        tvline = tv.function.CFGroot.nextnode[0].line_begin
                                        tvcolumn = tv.function.CFGroot.nextnode[0].column_begin
                                    piked = False
                                    for t in targets:
                                        if (t.ent == nextent) and (t.startingpoint == tvline):
                                            piked = True
                                            break
                                    if not piked:
                                        for t in tracked:
                                            if (t.ent == nextent) and (t.startingpoint == tvline):
                                                piked = True
                                                break
                                    if not piked:
                                        # 構造体のメンバかを確認
                                        nnext = nexttoken.next()
                                        while (nnext is not None) and (nnext.token() in spacetokens):
                                            nnext = nnext.next()
                                        if (nnext is not None) and (nnext.text in [".", "->"]):
                                            nnext = nnext.next()
                                            while (nnext is not None) and (nnext.token() in spacetokens):
                                                nnext = nnext.next()
                                            targets.append(FixedTimeVal(nextent, tv.function, nnext.text(), tv.isyear, tvline, tvcolumn))
                                        else:
                                            targets.append(FixedTimeVal(nextent, tv.function, None, tv.isyear, tvline, tvcolumn))
                                nexttoken = nexttoken.next()
                        # 戻り値として利用されている場合、現在の関数の呼び出し文を追跡対象に加える
                        elif ("Return" in rkind):
                            picked = False
                            for t in targets:
                                if t.ent == tv.function.obj:
                                    picked = True
                                    break
                            if not picked:
                                for t in tracked:
                                    if t.ent == tv.function.obj:
                                        picked = True
                                        break
                            if not picked:
                                for call in tv.function.obj.refs("Callby"):
                                    if call.file() == file.ent:
                                        targets.append(FixedTimeVal(tv.function.obj, file.whereIsHere(call.line()), tv.memname, tv.isyear, call.line(), call.column()))
                # 追跡を続行する場合、次のノードを取り出す
                if not nocontinue:
                    for nnode in node.nextnode:
                        if (nnode.metanum not in visited) and (nnode not in tovisit):
                            tovisit.append(nnode)
        else:
            # ターゲット変数が関数に属さない場合（実際それを検出できてここに入ることがあるかは不明）
            pass
    # 重複（行と列の一致）チェック
    for ctf in comparetofix:
        listlength = len(comparetofix)
        for ind, targ in enumerate(reversed(comparetofix)):
            if ctf == targ:
                break
            if (ctf[2] == targ[2]) and (ctf[3] == targ[3]):
                comparetofix.pop(listlength - ind -1)
    return comparetofix

def nodeSearcher(line, startnode):
    """Search PDG node with the Line number"""
    tovisit = collections.deque([startnode])
    visited = []
    while tovisit:
        node = tovisit.popleft()
        if (node.line_begin <= line) and (line <= node.line_end):
            return node
        else:
            visited.append(node.metanum)
            for nnode in node.nextnode:
                if (nnode.metanum not in visited) and (nnode not in tovisit):
                    tovisit.append(nnode)
    return None

def loggingwrappers(newdemands):
    """Updating WrapperDemands"""
    global wrapperdemands

    for ind, d in enumerate(newdemands):
        if d == 1:
            wrapperdemands[ind] = 1

def callFixer(list, lexer, contents, gaps, flog):
    """Fixing calling sentence"""
    if list:
        contents.insert(0, "#include \"timewrap.h\"\n")
        print("===== Rewrite Calling =====")
        flog.write("===== Rewrite Calling =====\n")  # to log
    for call in list:
        token = lexer.lexeme(call[0].line(), call[0].column())
        line = token.line_begin()
        column = token.column_begin()
        if column > 0:
            contents[line] = contents[line][:column+gaps[line]] + "wrapper_" + contents[line][column+gaps[line]:]  # include記述で1行ずれるのでline-1にしなくていい
        elif column == 0:   # column=0の修正箇所は他の修正が差し挟まる可能性がない
            contents[line] = "wrapper_" + contents[line]  # 同上
        print("line:" + str(line) + " column:" + str(column+gaps[line]))
        flog.write("line:" + str(line) + " column:" + str(column+gaps[line]) + "\n") # to log
        gaps[line] = gaps[line] + 8
    print("===== End =====")
    flog.write("===== End =====\n")  # to log
    return contents

def compareFixer(list, lexer, contents, gaps, args, flog):
    """"Fixing and Noticing comparing sentence"""
    global defersec
    alertoutput = []
    fixing = []
    # listから１つ取り出し
    for tofix in list:
    # tvの種別（年情報かどうか、文字情報かどうか）を確認
        if (tv := tofix[1]).type == "String":
            # 文字情報は出力のみ
            alertoutput.append(tofix)
        elif (type(tv.isyear) is str) and (tv.isyear == "Unknown"):
            # 正体不明の関数の戻り値を保持しているため情報の内容が不明のもの
            alertoutput.append(tofix)
        elif tv.isyear:
            # 年情報は「2038」あるいは「1969」にかかわる値かをチェックし、それらの場合のみ修正。そうでなければ出力のみとする
            if tofix[3] < tofix[0].column():
                token = lexer.lexeme(tofix[2], tofix[3]).previous()
                while token.token() in ["Whitespace", "Panctuation"]:
                    token = token.previous()
            else:
                token = lexer.lexeme(tofix[2], tofix[3]).next()
                while token.token() in ["Whitespace", "Panctuation"]:
                    token = token.next()
            if token.token() not in ["Newline", "Comment", "EndOfStatement"]:
                if token.text() in ["68", "69", "70", "37", "38", "39", "137", "138", "139"]:
                    if tv.ismember:
                        tvtoken = lexer.lexeme(tofix[0].line(), tofix[0].column()).next()
                        while (tvtoken is not None) and ((tvtoken.text() in ["->", ".", "*", "&"]) or (tvtoken.token() in ["Whitespace", "Indent", "Dedent"])):
                            tvtoken = tvtoken.next()
                        if (tvtoken is None) or ((tvtoken.text() != tv.memname) and (tvtoken.token() == "Identifier")):  # 構造体のメンバ一致確認
                            alertoutput.append(tofix)
                        elif tvtoken.text() == tv.memname:
                            position = tvtoken.column_end() + 1
                            fixing.append([tofix, position, True])  # [2]は年情報か
                        else:
                            alertoutput.append(tofix)
                    else:
                        position = lexer.lexeme(tofix[0].line(), tofix[0].column()).column_end() + 1
                        fixing.append([tofix, position, True])
                else:
                    alertoutput.append(tofix)
        else:
            # time_t互換値の場合、すべて修正
            position = lexer.lexeme(tofix[0].line(), tofix[0].column()).column_end() + 1
            fixing.append([tofix, position, False])
    print("===== Probably need to fix =====\n")
    flog.write("===== Probably need to fix =====\n\n")   # to log
    for fix in fixing:
        print("  Line:" + str(fix[0][0].line()), end="")
        flog.write("  Line:" + str(fix[0][0].line()))    # to log
        print("  Column:" + str(fix[0][0].column() + 1))
        flog.write("  Column:" + str(fix[0][0].column() + 1) + "\n")    # to log
        print("Original:" + contents[fix[0][2] - 1], end="")
        flog.write("Original:" + contents[fix[0][2] - 1])    # to log
        # 修正文の作成・提示
        fixline = fix[0][2]
        fixtext = contents[fixline - 1]
        if fix[2]:
            fixtext = fixtext[:fix[1]+gaps[fixline - 1]] + "-" + str(newepoch-oldepoch) + fixtext[fix[1]+gaps[fixline - 1]:]
        else:
            fixtext = fixtext[:fix[1]+gaps[fixline - 1]] + "+" + str(defersec) + fixtext[fix[1]+gaps[fixline - 1]:]
        print("Proposal:" + fixtext)
        flog.write("Proposal:" + fixtext + "\n") # to log
        if args.autoapprove:
            answer = "y"
        elif args.autoreject:
            answer = "n"
        else:
            answer = input("Approve this? y/n > ")
            while answer not in ["y", "n"]:
                answer = input("Please input y or n > ")
        if answer == "y":
            flog.write("Approve this? y/n > y\n")    # to log
            contents[fixline - 1] = fixtext
            if fix[2]:
                gaps[fixline - 1] = gaps[fixline - 1] + len(str(newepoch-oldepoch)) + 1
            else:
                gaps[fixline - 1] = gaps[fixline - 1] + len(str(defersec)) + 1
        elif answer == "n":
            flog.write("Approve this? y/n > n\n")    # to log
            pass
        print("")
        flog.write("\n") # to log
    # 出力のみの場合
    print("===== Possibly need to fix =====\n")
    flog.write("===== Possibly need to fix =====\n\n")   # to log
    for alert in alertoutput:
        print("  Line:" + str(alert[0].line()), end="")
        flog.write("  Line:" + str(alert[0].line())) # to log
        print("  Column:" + str(alert[0].column() + gaps[alert[0].line() - 1] + 1))
        flog.write("  Column:" + str(alert[0].column() + gaps[alert[0].line() - 1] + 1) + "\n")  # to log
        print(contents[alert[2] - 1], end="")
        flog.write(contents[alert[2] - 1])   # to log
        count = 1
        column = alert[3] + gaps[alert[0].line() - 1] + 1
        while count < column:
            print(" ", end="")
            flog.write(" ")  # to log
            count = count + 1
        print("^\n")
        flog.write("^\n\n")  # to log
    return contents

def makeWrapper(exists, args):
    """Making wrapper functions file"""
    global logfile
    body = []
    head = []
    head.append("#pragma once\n")
    head.append("\n")
    head.append("#include <time.h>\n")
    head.append("\n")
    body.append("#include <time.h>\n")
    body.append("#include \"timewrap.h\"\n")
    body.append("\n")
    if (exists[0] == 1) or (exists[1] == 1):
        # year-string shifter for ctime and ctime_r
        head.append("\n")
        head.append("char *retshift(char *ret);\n")
        body.append("\n")
        body.append("char *retshift(char *ret){\n")
        body.append("    int count, year = 0;\n")
        body.append("    for(count = 0; count < 4; count++){\n")
        body.append("        year *= 10;\n")
        body.append("        year += ret[20+count] - 48;\n")
        body.append("    }\n")
        body.append("    year -= 28;\n")
        body.append("    for(count = 3; count >= 0; count--){\n")
        body.append("        ret[20+count] = (year % 10) + 48;\n")
        body.append("        year /= 10;\n")
        body.append("    }\n")
        body.append("    return ret;\n")
        body.append("}\n")
    if exists[0] == 1:
        # <ctime>
        head.append("\n")
        head.append("char *wrapper_ctime(const time_t *timer);\n")
        body.append("\n")
        body.append("char *wrapper_ctime(const time_t *timer){\n")
        body.append("    return retshift(ctime(timer));\n")
        body.append("}\n")
    if exists[1] == 1:
        # <ctime_r>
        head.append("\n")
        head.append("char *wrapper_ctime_r(const time_t *timer, char *buf);\n")
        body.append("\n")
        body.append("char *wrapper_ctime_r(const time_t *timer, char *buf){\n")
        body.append("    ctime_r(timer, buf);\n")
        body.append("    buf = retshift(buf);\n")
        body.append("    return buf;\n")
        body.append("}\n")
    if exists[2] == 1:
        # <gmtime>
        head.append("\n")
        head.append("struct tm *wrapper_gmtime(const time_t *timer);\n")
        body.append("\n")
        body.append("struct tm *wrapper_gmtime(const time_t *timer){\n")
        body.append("    struct tm *ret;\n")
        body.append("    ret = gmtime(timer);\n")
        body.append("    ret->tm_year += 28;\n")
        body.append("    return ret;\n")
        body.append("}\n")
    if exists[3] == 1:
        # <gmtime_r>
        head.append("\n")
        head.append("struct tm *wrapper_gmtime_r(const time_t *timer, struct tm *result);\n")
        body.append("\n")
        body.append("struct tm *wrapper_gmtime_r(const time_t *timer, struct tm *result){\n")
        body.append("    gmtime_r(timer, result);\n")
        body.append("    result->tm_year += 28;\n")
        body.append("    return result;\n")
        body.append("}\n")
    if exists[4] == 1:
        # <localtime>
        head.append("\n")
        head.append("struct tm *wrapper_localtime(const time_t *timer);\n")
        body.append("\n")
        body.append("struct tm *wrapper_localtime(const time_t *timer){\n")
        body.append("    struct tm *ret;\n")
        body.append("    ret = localtime(timer);\n")
        body.append("    ret->tm_year += 28;\n")
        body.append("    return ret;\n")
        body.append("}\n")
    if exists[5] == 1:
        # <localtime_r>
        head.append("\n")
        head.append("struct tm *wrapper_localtime_r(const time_t *timer, struct tm *result);\n")
        body.append("\n")
        body.append("struct tm *wrapper_localtime_r(const time_t *timer, struct tm *result){\n")
        body.append("    localtime_r(timer, result);\n")
        body.append("    result->tm_year += 28;\n")
        body.append("    return result;\n")
        body.append("}\n")
    if exists[6] == 1:
        # <mktime>
        head.append("\n")
        head.append("time_t wrapper_mktime(struct tm *tm);\n")
        body.append("\n")
        body.append("time_t wrapper_mktime(struct tm *tm){\n")
        body.append("    tm->tm_year -= 28;\n")
        body.append("    return mktime(tm);\n")
        body.append("}\n")
    if exists[7] == 1:
        # <timegm>
        head.append("\n")
        head.append("time_t wrapper_timegm(struct tm *tm);\n")
        body.append("\n")
        body.append("time_t wrapper_timegm(struct tm *tm){\n")
        body.append("    tm->tm_year -= 28;\n")
        body.append("    return timegm(tm);\n")
        body.append("}\n")
    if exists[8] == 1:
        # <timelocal>
        head.append("\n")
        head.append("time_t wrapper_timelocal(struct tm *tm);\n")
        body.append("\n")
        body.append("time_t wrapper_timelocal(struct tm *tm){\n")
        body.append("    tm->tm_year -= 28;/n")
        body.append("    return timelocal(tm);\n")
        body.append("}\n")
    if 1 in exists:
        # ラッパー関数ファイルを作成するフォルダの確認
        if args.usecurrentdirectory:
            dirpath = None
        else:
            dirpath = input("Enter Directory Path for Wrapper Sourcefile (if empty, create in current dir) > ")
        if not dirpath:
            headerpath = "timewrap.h"
            sourcepath = "timewrap.c"
        else:
            headerpath = dirpath + os.sep + "timewrap.h"
            sourcepath = dirpath + os.sep + "timewrap.c"
        with open(headerpath, 'w', encoding='utf-8') as fw:
            print("Header File creating...", end="")
            logfile.write("Header File creating...")    # to log
            fw.writelines(head)
            print("OK")
            logfile.write("OK\n")   # to log
        with open(sourcepath, 'w', encoding='utf-8') as fw:
            print("Source File creating...", end="")
            logfile.write("Source File creating...")    # to log
            fw.writelines(body)
            print("OK")
            logfile.write("OK\n")   # to log

def argumentSolver():
    parser = argparse.ArgumentParser(description='C source code semi-auto fixer for year-2038 problem.')
    parser.add_argument('-aa', '--autoapprove', action='store_true', help='Approve all fix proposal. This option has priority over --autoreject(-ar).')
    parser.add_argument('-ar', '--autoreject', action='store_true', help='Reject all fix proposal. This option is overridden by --autoapprove(-aa).')
    parser.add_argument('-cd', '--usecurrentdirectory', action='store_true', help='Auto select current directory as the place to put wrapper sorcefiles.')
    parser.add_argument('-fsl', '--filesizelimit', type=int, default=1048576, help='The files that is bigger than this size (byte) are skipped analyzing. Default value is 1,048,576(1MB).')
    parser.add_argument('-fll', '--functionlinelimit', type=int, default=5000, help='The files containing functions consisting of lines longer than this value will be skipped analyzing. Default value is 5000.')
    args = parser.parse_args()
    return args

if __name__ == '__main__':
    # Define defer year
    oldepoch = 1970
    newepoch = 1998
    defersec = '883612800'

    funclist = []
    filelist = []   # [filename, filepath(inputed path by user), file-entity, lexer]
    cantanalyzed = []
    wrapperdemands = [0, 0, 0, 0, 0, 0, 0, 0, 0]    # 作成が必要なラッパー関数を記憶するリスト

    args = argumentSolver()

    os.makedirs("fixer2038_logs", exist_ok=True)
    logfile = open("fixer2038_logs" + os.sep + "fixer2038log.txt", mode='w')
    logfile.write(datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S') + "\n")    # to log

    pathlist = makeFileList()
    # for p in pathlist:
    #     filelist.append([pathParse(p), p])
    analyzeCode()
    unddb = understand.open("newDB.udb")
    entlist = unddb.ents()
    fileents = unddb.ents("File")
    for e in fileents:
        for f in pathlist:
            if e.longname().endswith(f):
                nf = TheFile(e)
                filelist.append(nf)
                nf.addLexer(e.lexer())
            # if f[1].endswith(e.relname()):
            #     f.extend([e, e.lexer()])
            #     break
    for f in unddb.ents("Function"):
        tf = TheFunction(f)
        funclist.append(tf)
        tf.declareCheck(filelist)
    r = drawPDG(funclist)
    if len(r) != 0:
        for error in r:
            if error[1].declaredfile in filelist:
                filelist.remove(error[1].declaredfile)
                cantanalyzed.append([error[0], error[1].declaredfile.path])
    buildPDG(filelist)
    targetfuncs = searchTargetFunction(unddb)

    # 1つのファイル、そのlexer、そのパスをセットで探す
    for f in filelist:
        fixManager(f, targetfuncs, funclist, args)
        # for path in pathlist:
        #     if path == fandl[1]:
        #         fixManager(fandl[2], fandl[3], path, targetfuncs, funclist, args)
    makeWrapper(wrapperdemands, args)

    if cantanalyzed:
        print("These files couldn\'t be analyzed.")
        logfile.write("\n")
        logfile.write("These files couldn\'t be analyzed.\n")
        for c in cantanalyzed:
            print("  " + c[0] + "\t" + c[1])
            logfile.write("  " + c[0] + "\t" + c[1] + "\n")

    logfile.write(datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S') + "\n")    # to log
    logfile.close()